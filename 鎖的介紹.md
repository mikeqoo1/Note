# 基本概論

原文網址：https://kknews.cc/tech/jlx2qql.html

- 關於Redis分散式鎖這一篇應該是講的最好的了，先收藏起來再看！ https://www.gushiciku.cn/pl/gkKm/zh-tw
- golang實現簡單的分散式鎖 https://www.gushiciku.cn/pl/2nox/zh-tw
- golang實現簡單的分散式鎖 https://www.itread01.com/content/1549812998.html
## 互斥鎖
```
互斥鎖是一種實現線程同步的機制：當一個線程嘗試獲取互斥鎖，如果互斥鎖已經被占用則該線程會被掛起進入睡眠狀態，直到被喚醒。線程被掛起時，CPU會將該線程當前的處理狀態保存到內存中，等到喚醒時從內存中讀取上次的處理狀態，這個CPU切換線程處理狀態的過程被稱為「上下文切換」。上下文切換是一個非常耗時的操作，它需要相當多的CPU指令才能完成。但在早期單核處理器中，只能通過這個方式來完成，畢竟一口鍋不能同時炒兩盤不一樣的菜。
```
## 自旋鎖
```
多核處理器開始普及之後，使用互斥鎖經常會出現一種尷尬的情況：一個線程因為嘗試獲取互斥鎖失敗而進入睡眠狀態，但上下文切換還沒完成或者說剛切換上下文沒多久，另一個線程就已經釋放了那個互斥鎖(所以出現了自旋鎖)。
```
### 概念
```
自旋鎖是為實現保護共享資源而提出一種鎖機制。其實，自旋鎖與互斥鎖比較類似，它們都是為了解決對某項資源的互斥使用。無論是互斥鎖，還是自旋鎖，在任何時刻，最多只能有一個保持者，也就說，在任何時刻最多只能有一個執行單元獲得鎖。但是兩者在調度機制上略有不同。對於互斥鎖，如果資源已經被占用，資源申請者只能進入睡眠狀態。但是自旋鎖不會引起調用者睡眠，如果自旋鎖已經被別的執行單元保持，調用者就一直循環在那裡看是否該自旋鎖的保持者已經釋放了鎖，」自旋」一詞就是因此而得名。
```
### 自旋鎖和互斥鎖一樣也是實現線程同步的一種機制
```
當一個線程嘗試獲取自旋鎖時，如果自旋鎖已經被占用則該線程會一直循環等待並反覆檢查鎖是否可用，直到鎖可用時才會退出循環。如果持有鎖的線程很快就釋放了並且線程競爭不激烈，那自旋的效率就非常好，反之，自旋就會白白浪費CPU的處理時間，這反而會帶來性能上的損失。
```
### 問題
- 如果某個線程持有鎖的時間過長，就會導致其它等待獲取鎖的線程進入循環等待，消耗CPU。使用不當會造成CPU使用率極高。
- 不公平的鎖(即無法滿足等待時間最長的線程優先獲取鎖)就會存在」線程飢餓」問題。
- 在用自旋鎖時有可能造成死鎖，當遞歸調用時有可能造成死鎖，調用有些其他函數也可能造成死鎖，如 copy_to_user()、copy_from_user()、kmalloc()等
### 說明
```
我們要慎重使用自旋鎖，自旋鎖只有在內核可搶占式或SMP的情況下才真正需要，在單CPU且不可搶占式的內核下，自旋鎖的操作為空操作。自旋鎖適用於鎖使用者保持鎖時間比較短的情況下。
```
### 優點
```
自旋鎖不會使線程狀態發生切換，一直處於用戶態，即線程一直都是active的；不會使線程進入阻塞狀態，減少了不必要的上下文切換，執行速度快(非自旋鎖在獲取不到鎖的時候會進入阻塞狀態，從而進入內核態，當獲取到鎖的時候需要從內核態恢復，需要線程上下文切換)
```
### 特點
```
單CPU非搶占內核下： 自旋鎖會在編譯時被忽略（因為單CPU且非搶占模式情況下，不可能發生進程切換，時鐘只有一個進程處於臨界區（自旋鎖實際沒什麼用了）
單CPU搶占內核下： 自選鎖僅僅當作一個設置搶占的開關（因為單CPU不可能有並發訪問臨界區的情況，禁止搶占就可以保證臨街區唯一被擁有）
多CPU下： 此時才能完全發揮自旋鎖的作用，自旋鎖在內核中主要用來防止多處理器中並發訪問臨界區，防止內核搶占造成的競爭。
```
### 自旋鎖與互斥鎖
#### 原理
互斥鎖：線程會從sleep（加鎖）——>running（解鎖），過程中有上下文的切換，cpu的搶占，信號的發送等開銷。
自旋鎖：線程一直是running(加鎖——>解鎖)，死循環檢測鎖的標誌位。
用一句話概括互斥鎖和自旋鎖：互斥鎖是睡等，自旋鎖是忙等。

#### 區別
性能問題
```
互斥鎖的起始原始開銷要高於自旋鎖，但是基本是一勞永逸，臨界區持鎖時間的大小並不會對互斥鎖的開銷造成影響，而自旋鎖是死循環檢測，加鎖全程消耗cpu，起始開銷雖然低於互斥鎖，但是隨著持鎖時間，加鎖的開銷是線性增長。
釋放問題

自旋鎖你不需要操心鎖持有進(線)程意外結束(加鎖到解鎖過程中進程被kill了)的時候，鎖的釋放問題(需要寫點代碼)
互斥鎖最好用於那種生命周期特別長和特別穩定的代碼段，例如中斷處理例程內核代碼。
其它(互斥鎖看做二元信號量)

信號量和讀寫信號量適合於保持時間較長的情況，它們會導致調用者睡眠，因而自旋鎖適合於保持時間非常短的情況。
自旋鎖可以用於中斷，不能用於進程上下文(會引起死鎖)。而信號量不允許使用在中斷中，而可以用於進程上下文。
自旋鎖保持期間是搶占失效的，自旋鎖被持有時，內核不能被搶占，而信號量和讀寫信號量保持期間是可以被搶占的。
```
應用
```
互斥鎖
(互斥鎖用於臨界區持鎖時間比較長的操作，比如下面這些情況都可以考慮)
1.臨界區有IO操作
2.臨界區代碼複雜或者循環量大
3.被保護的共享資源只在進程上下文訪問
4.臨界區競爭非常激烈
5.單核處理器
```
```
自旋鎖

主要用在臨界區持鎖時間非常短且CPU資源不緊張的情況下，自旋鎖一般用於多核的伺服器。
被保護的共享資源需要在中斷上下文訪問(包括底半部(中斷處理句柄)和頂半部(軟中斷))
```
### 總結
```
自旋鎖的初衷就是：在短期間內進行輕量級的鎖定。一個被爭用的自旋鎖使得請求它的線程在等待鎖重新可用的期間進行自旋(特別浪費處理器時間)，所以自旋鎖不應該被持有時間過長。如果需要長時間鎖定的話, 最好使用信號量。

既然互斥鎖與自旋鎖各有優劣，我們可以把它們結合到一起：當一個線程獲取鎖失敗，先讓它自旋一段時間，一段時間過後還未能獲取鎖，再讓它進入睡眠狀態。這個過程的重點在於自旋時間的長短，過長可能退化成單純的自旋鎖，過短可能退化成互斥鎖。
```
